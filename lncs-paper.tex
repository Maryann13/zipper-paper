% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.20 of 2017/10/04
%
\documentclass[runningheads]{llncs}
%
\usepackage{graphicx}
\usepackage{url}
\usepackage{amssymb}

\urlstyle{same}
% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
% If you use the hyperref package, please uncomment the following line
% to display URLs in blue roman font according to Springer's eBook style:
%\renewcommand\UrlFont{\color{blue}\rmfamily}

\newcommand{\s}{$\hphantom{~}$}
\newcommand{\ind}{\s\s\s\s}
\newcommand{\hs}{\hspace{0.06cm}}
\newcommand{\ths}{\hspace{0.01cm}}
\newcommand{\tths}{\hspace{0.003cm}}
\newcommand{\nths}{\hspace{-0.01cm}}
\newcommand{\nhs}{\hspace{-0.06cm}}
\newcommand{\vs}{\vspace{0.2cm}\\}

\newcommand{\Ra}{$\Rightarrow$\s}
\newcommand{\ra}{$\rightarrow$\s}
\newcommand{\fa}{$\forall$}
\newcommand{\tteq}{{\scriptsize$\thicksim$}\s}
\newcommand{\comp}{{\tt>\nhs>\nhs>}}
\newcommand{\kleisli}{{\tt>\nhs=\nhs>}}
\newcommand{\comps}{\comp\s}
\newcommand{\kleislis}{\kleisli\s}
\newcommand{\ann}{:\nhs:\s}


\begin{document}
%
\title{Handling Recursion in Generic Programming Using Closed Type Families}
%
%\titlerunning{Abbreviated paper title}
% If the paper title is too long for the running head, you can set
% an abbreviated paper title here
%
\author{Anna Bolotina\inst{1} \and
Artem Pelenitsyn\inst{2}
}
%
%\authorrunning{F. Author and S. Author}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
\institute{Southern Federal University, Rostov-on-Don, Russia\\
\email{bolotina@sfedu.ru} \and
Czech Technical University in Prague, Prague, Czech Republic\\
\email{pelenart@fit.cvut.cz}}
%
\maketitle              % typeset the header of the contribution
%
\begin{abstract}
Many of the extensively used libraries for datatype-generic programming offer a fixed-point view on datatypes to express their recursive structure. However, some approaches, based on sums of products, do not use a fixed point. They allow for generic functions that do not require to look at the recursive knots in a datatype representation, but raise issues otherwise. A known and unwelcome solution is the use of overlapping instances. We present an alternative approach that uses closed type families to eliminate the need of overlap for handling recursion in datatypes. Moreover, we show that our idiom allows for families of mutually recursive datatypes.


\textbf{Category:} full research paper.

\textbf{Studentship:} both authors are students.

%The \textsf{generics-sop} library is an approach to representing data using $n$-ary sums and products that both are list-like structures, which is different from the classical view where datatypes are expressed by separate binary sums and products, and it does not encode recursive knots explicitly as with the fixed-point view. We choose this approach as a case study to demonstrate our solution.

\keywords{Datatype-generic programming \and Sums of products \and Recursion \and Overlapping instances \and Closed type families \and Zipper \and Mutually recursive datatypes \and Haskell.}
\end{abstract}
%
%
%
\section{Introduction}
\label{sec:introduction}

A classical way to generically express a datatype is to represent its constructors as the chains of nested \emph{binary} sums, and turn constructor arguments into the chains of nested \emph{binary} products~\cite{VanNoort2008,Cheney2002,Loeh2004}\nocite{Rodriguez2008}\nocite{Magalhaes2012}. De Vries and L\"{o}h~\cite{VriLoeh2014} describe a different sum-of-products approach to representing data using $n$-ary sums and products that are both lists of types; a sum of products is thus a list of lists of types. They call their view SOP which stands for a ``sum of products''. It is implemented in the \textsf{generics-sop}~\cite{generics-sop} library and is based on several relatively recent extensions to the Haskell type system, such as \emph{data kinds}, \emph{kind polymorphism}~\cite{Yorgey2012} and \emph{constraint kinds}.
%, and \emph{GADTs}~\cite{Schrijvers2009}. -- very old extension, 2003 approx.
Using these Haskell features, the library provides the generic view and equips it with a rich collection of high-level combinators, such as ones for constructing sums and products, collapsing to homogeneous structures, and others. They form an expressive instrument for defining generic functions in a more succinct and high-level style as compared to the classical binary sum-of-products views.

There are many generic functions that deal with the recursive knots when traversing the structure of datatypes. Some of the most general examples are \emph{maps}~\cite{Magalhaes2010} and \emph{folds}~\cite{Meijer1991}; more advanced one is a \emph{zipper}~\cite{Huet1997,HiJeLo2004,Adams2010}. For handling recursion, several generic programming approaches express datatypes in the form of polynomial functors closed under fixed points~\cite{MuRec2009,Jansson1997,Loeh2011}. The SOP view naturally supports definitions of functions that do not require a knowledge about recursive occurrences, but otherwise becomes unhandy.

One possible solution to the aforementioned shortcoming of SOP is to modify its core by explicitly encoding recursive positions using the fixed-point approach. However, this may complicate the whole framework significantly. Besides, such a decision may lead to extra conversions between the generic views.

Another known solution uses overlapping instances. This, usually unwelcome, Haskell extension complicates reasoning about the semantics of code. In particular, the program behavior becomes unstable, for it can be affected by any module defining more specific instances. Morris and Jones~\cite{Morris2010} extensively discuss the problems arising from overlapping instances.
% and introduce the type system \textsf{ilab} with a feature called \emph{instance chains} that advances control of overlap. 
The overlap problem also strikes in the security setting when code is compiled as \texttt{-XSafe} because GHC does not reflect unsafe overlaps and marks the module as safe~\cite{sh-overlapping}.
%Kiselyov et al.~\cite{Kiselyov2004} show how to localize overlap for access operations in a systematic way. Using \textit{closed type families}~\cite{Eisenberg2014}, we introduce an idiom that allows us to completely eliminate overlap for handling recursion.
% -- this should go to Realted Work (if stays in the paper at all)

We feel both existing approaches unsatisfactory and make the following contributions.
\begin{itemize}
\item We describe the problem with the current approach of SOP in detail (Section~\ref{sec:sop-problem}).
\item We introduce an idiom that overcomes the problem. The approach avoids both, the use of overlapping instances and changing a generic representation. (Section~\ref{sec:handling-recursion})
% -- 
%\item We provide a convenient interface for generic functions: there is no need to manually declare type class instances for using them.
% -- this doesn't sound like a contribution
\item We evaluate our approach through the development of a larger-scale use case---the generic zipper. The zipper is meant to be easily and flexibly used with families of mutually recursive datatypes (Section~\ref{sec:generic-zipper}).
\item We note, that our approach can contribute to the \textsf{generics-sop}'s one eliminating some boilerplate instance declarations, which necessarily  arise in practice as a consequence of absence of information about recursion points. An example of that, taken from the \textsf{basic-sop}~\cite{basic-sop} package, is discussed in Section~\ref{sec:gshow}.
\end{itemize}

We believe that our idea is suitable for any sum-of-products approach that do not exploit the fixed point view and thus subject to the problem. We choose the \textsf{generics-sop} approach as a case study because it appears to be a widely applicable library and builds on powerful language extensions implemented in GHC.

\section{The SOP universe and the problem}
\label{sec:sop-problem}

In this section, we first review the SOP view on data, describing its basic concepts to introduce the terminology we are using. Then we discuss the problem with handling recursion by generic functions and illustrate it with a short example.

\subsection{The SOP view}
\label{sec:sop-view}

We first explain the terminology we adopt from SOP~\cite{VriLoeh2014,Loeh2015} and use throughout the paper. The main idea of the SOP view is to use $n$-ary sums and products to represent a datatype as an isomorphic code whose kind is a list of lists of types. The SOP approach expresses the code using the \textsf{DataKinds} extension, with a type family:
\texttt{
\vs
\indent\textbf{type family} Code (a \ann *) \ann [[*]]
\vs
}
An $n$-ary sum and an $n$-ary product are therefore modelled as type-level heterogeneous lists: the inner list is an $n$-ary product that represents a sequence of constructor arguments, while the outer list, an $n$-ary sum, corresponds to a choice of a particular constructor.

Consider, for instance, a datatype of binary trees:
\texttt{
\vs
\indent\textbf{data} Tree a = Leaf a | Node (Tree a) (Tree a)
\vs
}
This datatype is isomorphic to the following code:
\texttt{
\vs
\indent\textbf{type instance} Code (Tree a) = '[ '[a], '[Tree a, Tree a]]
\vspace{0.2cm}
}

\begin{figure}[t]
\centering
\normalsize
\begin{tabular}{l}
\tt \textbf{data} NP (f \ann k \ra *) (xs \ann [k]) \textbf{where}\\
\tt\s\s Nil\s\s \ann NP f '[]\\
\tt\s\s (:*) \ann f x \ra NP f xs \ra NP f (x ': xs)
\vs
\tt \textbf{data} NS (f \ann k \ra *) (xs \ann [k]) \textbf{where}\\
\tt\s\s Z \ann f x \ra NS f (x ': xs)\\
\tt\s\s S \ann NS f xs \ra NS f (x ': xs)
\end{tabular}
\caption{Datatypes for $n$-ary sums and products.}
\label{fig:ns-np}
\end{figure}

%A type of promoted lists has no inhabitants, so the universe provides datatypes to operate on $n$-ary sums and products as on terms.
% -- this sentence falls out of the flow of the paragraph

As shown in Figure~\ref{fig:ns-np}, the datatypes \texttt{NS} for an $n$-ary sum and \texttt{NP} for an $n$-ary product are defined as GADTs and are \emph{indexed}~\cite{HiJeLo2004} by a promoted list of types. The encoding also holds an auxiliary type constructor \texttt{f} (typically, a functor) which is meant to be applied to every element of the index list. Therefore, \texttt{NP} is a modest abstraction over a heterogeneous list. 

The definitions of \texttt{NS} and \texttt{NP} are kind polymorphic. The index list is allowed to contain types of arbitrary kind \texttt{k}, since \texttt{k} turns to \texttt{*} by applying the type constructor \texttt{f}.
Basic instantiations of type parameter \texttt{f} found in SOP are identity functor \texttt{I}, that is, a type-level equivalent for \texttt{id} function, and a constant functor \texttt{K}, an analogue of \texttt{const}:
\texttt{
\vs
\indent\textbf{newtype} I (a \ann *)\ind\ind\s\s\nhs = I \{unI \ann a\}\\
\indent\textbf{newtype} K (a \ann *) (b \ann k) = K \{unK \ann a\}
\vs
}
If instantiated with \texttt{I}, \texttt{NP} is a plain heterogeneous list, while \texttt{K a} turns it into a homogeneous one, isomorphic to \texttt{[a]}. Here is an example value of type \texttt{NP I}:
\texttt{
\vs
\indent I 5 :* I True :* I 'x' :* Nil \ann NP I '[Int, Bool, Char]
\vspace{0.2cm}
}

We turn to the sum definition now. The constructor \texttt{S} of \texttt{NS}, given an index in $n$-element list, results in an index in a list with $n+1$ elements, skipping the first one, while \texttt{Z} stores the payload of type \texttt{f x}. For example, the following chooses the third element of a sum:
\texttt{
\vs
\indent S (S (Z (I 5))) \ann NS I '[Char, Bool, Int, Bool]
\vs
}
The sum constructors are similar to Peano numbers, so the choice from a sum of products of a datatype matches the index of its particular constructor in the index list and stores the product representing arguments of that constructor.

With the \texttt{NS} and \texttt{NP} machinery at hand, SOP defines the \texttt{Generic} class with conversion functions \texttt{from} and \texttt{to} witnessing the isomorphism between a datatype and its generic representation:
\texttt{
\vs
\indent\textbf{type} Rep a = SOP I (Code a)
\vs
\indent\textbf{class} All SListI (Code a) \Ra Generic (a \ann *) \textbf{where}\\
\indent\s\s \textbf{type} Code a \ann [[*]]\\
\indent\s\s from \ann a \ra Rep a\\
\indent\s\s to\s\s\s \ann Rep a \ra a
\vs
}
The sum of products type, \texttt{SOP f}, is a newtype-wrapper for \texttt{NS (NP f)}, and the structural representation \texttt{Rep} of a datatype \texttt{a} is a type synonym for a \texttt{SOP I} of \texttt{a}'s code. The functions, \texttt{from} and \texttt{to}, perform a shallow conversion of the datatype topmost layer---they do not recursively translate the constructor arguments.

We leave out discussion of the \texttt{SListI} constraint in the \texttt{Generic} class definition as irrelevant to our work. Although, we do use \texttt{All} constraint combinator (as in \texttt{All SListI}) in the following. Therefore, it is worth noting that \texttt{All} applies a particular constraint (e.g. \texttt{SListI} above) to each member of a list of types. The usage of constraints as type arguments is allowed due to \textsf{ConstraintKinds} language extension introducing a dedicated kind \texttt{Constraint}.

We have introduced generic representation employed by the SOP library and are ready to describe the problem of handling recursion points, stemming from the representation. 

\subsection{Problem with handling recursion}
\label{sec:recursion-problem}

We illustrate the problem through a short example. The \textsf{QuickCheck} library~\cite{Claessen2011} for automatic testing of Haskell code defines a helper function \texttt{subterms} that takes a term and obtains a list of all its immediate subterms that are of the same type as the given term, that is, all the recursive positions in the term structure. We reimplement this function using the SOP view:
\texttt{
\vs
\indent subterms \ann Generic a \Ra a \ra [a]\\
\indent subterms t = subtermsNS (unSOP \$ from t)
\vs
\indent subtermsNS \ann NS (NP I) xss \ra [a]\\
\indent subtermsNS (S ns) = subtermsNS ns\\
\indent subtermsNS (Z np) = subtermsNP np
\vs
\indent subtermsNP \ann \fa a xs. NP I xs \ra [a]\\
\indent subtermsNP p (I y :* ys)\\
\indent\s\s | typeEq @a y \hs\hs\ths= witnessEq y : subtermsNP ys\\
\indent\s\s | otherwise\s\s\s\hs\hs\ths = subtermsNP ys\\
\indent subtermsNP \_ Nil = []
\vs
}
The function \texttt{subterms} translates the term to its representation, unwrapping the sum of products from \texttt{SOP}, and passes that to the auxiliary function \texttt{subtermsNS}. The latter merely traverses the sum and, once reaches the product,  passes it further to \texttt{subtermsNP}.

The algorithm of \texttt{subtermsNP} is straightforward---it traverses the product, appending current element to the result list if its type is the same as of the term \texttt{t}, otherwise skipping the element. We use GHC's \textsf{TypeAppications} extension to pass that type.

Now, we need a way to check type equality and, in the case of equal types, to witness that the element is of the desired type. There is no clear path to this at the moment. Therefore, we step back (until Section~\ref{subsec:solve-subtermnp}) and, to implement \texttt{subtermNP}, follow the \textsf{QuickCheck}'s example\footnote{The \textsf{QuickCheck} library applies another approach to generic programming, namely \textsf{GHC.Generics}.}, using overlapping instances of a dedicated class instead.
\texttt{
\vs
\indent\textbf{class} Subterms a (xs \ann [*]) \textbf{where}\\
\indent\s\s subtermsNP \ann NP I xs \ra [a]
\vs
\indent\textbf{instance} Subterms a xs \Ra Subterms a (x ': xs) \textbf{where}\\
\indent\s\s subtermsNP (\_\s\s\s :* xs) \hs\ths= subtermsNP xs\\
\indent\textbf{instance} \{-\# OVERLAPS \#-\}\\
\indent\ind\ind\s Subterms a xs \Ra Subterms a (a ': xs) \textbf{where}\\
\indent\s\s subtermsNP (I x :* xs) = x : subtermsNP xs\\
\indent\textbf{instance} Subterms a '[] \textbf{where}\\
\indent\s\s subtermsNP \_ = []
\vs
}

To make the whole solution work, we need to propagate the constraints all the way through \texttt{subtermsNS} and \texttt{subterms} signatures:
\texttt{
\vs
\indent subterms\s\s\s \ann\hs (Generic a, All (Subterms a) (Code a))\\
\indent\ind\ind\s\s\s \Ra a \ra [a]\\
\indent subtermsNS \ann\hs All (Subterms a) xss\\
\indent\ind\ind\s\s\s \Ra NS (NP I) xss \ra [a]
\vspace{0.2cm}
}

Although, the approach works, as exemplified by a number of the packages on Hackage, we aim for release of generic programs from overlap. This would remove the complexity overhead introduced by the approach, as we have mentioned in the introduction.


\section{Handling recursion with closed type families}
\label{sec:handling-recursion}


In the previous section, we have shown a solution to the problem of handling recursion, which uses overlapping instances. We are going to improve the solution and remove overlap now.

Closed type families are the Haskell language extension introduced by Eisenberg et al.~\cite{Eisenberg2014}. The main idea of the extension is that the equations for a \emph{closed type family} are disallowed outside its declaration. Under the extension, we can give the following definition of type-level equality:
\texttt{
\vs
\indent\textbf{type family} Equal a x \ann Bool \textbf{where}\\
\indent\s\s Equal a a = 'True\\
\indent\s\s Equal a x = 'False
\vs
}
The equations in a closed type family are matched in a top-to-bottom order. Since the order is fixed, the overlapping equations here cannot be used to define unsound type-level equations.

\subsection{Solution to \texttt{subtermsNP} revised}
\label{subsec:solve-subtermnp}

We now return to our running example from Section~\ref{sec:recursion-problem}. With the type equality, we can witness the coercion between equal types by defining a type class:
\texttt{
\vs
\indent\textbf{class} Proof (eq \ann Bool) (a \ann *) (b \ann *) \textbf{where}\\
\indent\s\s witnessEq \ann b \ra Maybe a
\vs
\indent\textbf{instance} Proof 'False a b \textbf{where}\\
\indent\s\s witnessEq \_ \hs\nths= Nothing\\
\indent\textbf{instance} Proof 'True\s\s a a \textbf{where}\\
\indent\s\s witnessEq\s\s\s = Just
\vs
}

For every element in a list of all direct subterms of a term we shall provide a proof object witnessing its type (in)equality to the type of the term. This can be done by means of the \texttt{All} combinator and partially applied auxiliary type class \texttt{ProofEq}, which abbreviates the heavy-weighted interface of \texttt{Proof}:
\texttt{
\vs
\indent\textbf{class}\ind Proof (Equal a b) a b \Ra ProofEq a b\\
\indent\textbf{instance} Proof (Equal a b) a b \Ra ProofEq a b
\vs
}
Resulting implementation of \texttt{subtermsNP} resembles our first definition given in the previous section:
\texttt{
\vs
\indent subtermsNP \ann \fa a xs. All (ProofEq a) xs \Ra NP I xs \ra [a]\\
\indent subtermsNP (I (y \ann x) :* ys)\\
\indent\s\s = case witnessEq @(Equal a x) y of\\
\indent\ind\s\s Just t\s\s \ra t : subtermsNP ys\\
\indent\ind\s\s  Nothing \ra subtermsNP  ys\\
\indent subtermsNP \_ Nil = []
\vs
}

As a side note, we make use of \textsf{ScopedTypeVariables} extension in the definition above, as the type of the element being matched does not appear in the function signature, since it may match an empty list. 

To complete the solution of the problem, the \texttt{ProofEq} constraint must be added to the \texttt{subterms} and \texttt{subtermsNS} declarations as well.

In summary, we claim that any generic function accessing recursive knots in the underlying datatype structure can be defined in the way described above for \texttt{subterms} task. We give another example showing how to adapt our idiom to different scenarios in the following subsection.

\subsection{Generic show}
\label{sec:gshow}

The function \texttt{show} is a common example of useful functions that traverse a datatype's recursive structure. It is known that this function can be defined in a generic way for an arbitrary datatype. De Vries and L\"{o}h define generic function \texttt{gshow} in the \textsf{basic-sop} package~\cite{basic-sop} based on the SOP view. We follow their implementation of \texttt{gshow} for the most part, but improve it in respect of handling recursion. The original \texttt{gshow} yields to the standard \texttt{show} generated through \texttt{\textbf{deriving} Show}, because it does not consult with recursion points to place parentheses. We eliminate this drawback.

The following exploits the idea of \emph{pattern matching}. As before, we consider two cases. In the first case, when the position we are matching on is not recursive, we only require it to be an  instance of \texttt{Show}, and invoke its \texttt{show} function. Whereas in the case of the recursive position, we surround it with parentheses and apply our generic function \texttt{gshow}. Thus, by means of the type family for equality, we model a form of pattern matching on the types again:
\texttt{
\vs
\indent\textbf{class} CaseShow (eq \ann Bool) (a \ann *) (b \ann *) \textbf{where}\\
\indent\s\s caseShow' \ann b \ra String
\vs
\indent\textbf{instance} Show\s\s b \Ra CaseShow 'False a b \textbf{where}\\
\indent\s\s caseShow'\s\s\s = show\\
\indent\textbf{instance} GShow a \Ra CaseShow 'True\s\s a a \textbf{where}\\
\indent\s\s caseShow' t = "(" ++ gshow t ++ ")"
\vs
}
We provide a synonym for the \texttt{CaseShow (Equal a b) a b} instance, which we call \texttt{CaseRecShow}, as before with \texttt{ProofEq}; likewise the synonym for the matching function:
\texttt{
\vs
\indent caseShow \ann \fa a b. CaseRecShow a b \Ra b \ra String\\
\indent caseShow t = caseShow' @(Equal a b) @a t
\vspace{0.2cm}
}

The resulting function \texttt{gshow} is a subject of a number of constraints abbreviated by \texttt{GShow} synonym:
\texttt{
\vs
\indent\textbf{type} GShow a = (Generic a, HasDatatypeInfo a,\\
\indent\ind\ind\ind\ind All2 (CaseRecShow a) (Code a))
\vs
\indent gshow \ann \fa a. GShow a \Ra a \ra String
\vs
}
The function \texttt{gshow} employs metadata provided by \textsf{generics-sop}'s class \texttt{Has\-Datatype\-Info} to show the names of a datatype constructor and its record fields. The \textsf{generics-sop} library is able to derive this metadata automatically.
The function is also constrained by \texttt{CaseRecShow} with the \texttt{All2} combinator that is an analogue of \texttt{All} for a list of lists of types. 

We define \texttt{gshow} mutually recursive with \texttt{caseShow}. The full implemenentation of the function \texttt{gshow} is left for the extended version of the paper in Technical Report\footnote{\url{https://users.fit.cvut.cz/~pelenart/2018-generic-zipper-tr.pdf}}.

The function \texttt{gshow} can now be used to generically show data---for example, a value of type \texttt{Tree~Bool}; note that \texttt{Tree~a} from Section~\ref{sec:sop-view} is now assumed to be an instance of \texttt{Generic} and \texttt{HasDatatypeInfo}.
\texttt{
\vs
\indent *Main> \textbf{let} tree = Node (Leaf True) (Leaf False)\\
\indent *Main> gshow tree
\vs
\indent "Node (Leaf True) (Leaf False)"
\vs
}
Here is a benefit of our implementation: it can be used directly, without any additional instance declarations, whereas \textsf{basic-sop}~\cite{basic-sop} offers the following usage pattern for \texttt{gshow} and some datatype \texttt{T}:
\texttt{
\vs
\indent\textbf{instance} Show T \textbf{where}\\
\indent\s\s show = gshow
\vs
}
This is a consequence of \texttt{gshow} from \textsf{basic-sop} not treating recursive positions separately, and therefore requiring the \texttt{Show} constraint for all knots in the datatype structure.


\section{The generic zipper}
\label{sec:generic-zipper}

The zipper is a data structure that enables efficient navigation and editing within the tree-like structure of a datatype. It represents a current location in that structure, storing a tree node, a \emph{focus}, along with its context. Having a zipper focused on a recursive knot in a structure, we may produce a new location by moving the focus up, down, left, or right. On the way, we can update the nodes. Entering and laving the navigation usually need a special care.

The classical zipper described by Huet~\cite{Huet1997} can be generically calculated for regular datatypes~\cite{HiJeLo2004}---a subset of datatypes that can be viewed as a least fixed point of some polynomial expression on types. Yakushev~et~al.~\cite{MuRec2009} generalize the definition of the generic zipper for an arbitrary family of mutually recursive datatypes. All mentioned solutions require a datatype to be expressed using forms of a fixed-point operator, since the zipper operates on recursion points. 

In this section, we describe our approach allowing one to define the generic zipper out of a representation that does not exploit a fixed point. We start with the generic zipper interface and an example of how it can be used (Section~\ref{ss:zip-interface}). Then, we turn to the type-level machinery employed to define locations inside mutually recursive datatypes using the SOP view  (Section~\ref{ss:locs}). Finally, we discuss the implementation of the generic zipper interface~--- the functions for manipulating locations (Section~\ref{ss:zip-impl}).

\subsection{Interface and usage}
\label{ss:zip-interface}

The interface we provide for the generic zipper is shown on Figure~\ref{fig:zipper-interface}. It comprises the functions for \emph{movement}, \emph{starting} and \emph{ending navigation}, and \emph{updating} the focus, which are defined over the location structure.
\begin{figure}[t]
\centering
\normalsize
\begin{tabular}{l}
\textbf{Movement functions}
\vs
\tt goUp\ind \ann Loc a fam c \ra Maybe (Loc a fam c)\\
\tt goDown\s\s \ann Loc a fam c \ra Maybe (Loc a fam c)\\
\tt goLeft\s\s \ann Loc a fam c \ra Maybe (Loc a fam c)\\
\tt goRight \ann Loc a fam c \ra Maybe (Loc a fam c)
\vspace{0.1cm}
\vs
\textbf{Starting navigation}
\vs
\tt enter\s\s\s \ann\hs \fa fam c a. (Generic a, In a fam, Zipper a fam c)\\
\tt\ind\ind \Ra a \ra Loc a fam c
\vspace{0.1cm}
\vs
\textbf{Ending navigation}
\vs
\tt leave\s\s\s \ann Loc a fam c \ra a
\vspace{0.1cm}
\vs
\textbf{Updating}
\vs
\tt update\s\s \ann (\fa b. c b \Ra b \ra b) \ra Loc a fam c \ra Loc a fam c
\end{tabular}
\caption{Generic zipper interface.}
\label{fig:zipper-interface}
\end{figure}

The functions \texttt{goUp}, \texttt{goDown}, \texttt{goLeft}, and \texttt{goRight} produce a location with the focus moved \emph{up} to the parent of the focal subtree, \emph{down} to its leftmost child, \emph{left} and \emph{right} to the left and right sibling, respectively, if it is possible. A movement may fail, as specified by the \texttt{Maybe} monad, if we cannot go further in a chosen direction. Navigation in a tree starts at the root, and the type variable \texttt{a} refers to the root type that remains the same during the navigation, while the type in the focus of the location may vary and is one of the types in a type list \texttt{fam}.

The function signature of \texttt{enter} specifies the constraints necessary to begin navigation in a structure. Firstly, a datatype of the structure needs to have the \texttt{Generic} representation. Secondly, the \texttt{In} constraint checks if type \texttt{a} is a member of a type family \texttt{fam}. Thirdly, the \texttt{Zipper} constraint collects specific constraints that refer to the implementation of movement operations. Note that the universal quantifier here sets the instantiation order of the type variables for type applications that will be a part of our usage pattern for the zipper. 

The \texttt{leave} function ends navigation moving up to the root and returns its modified value. 

The \texttt{update} function modifies the focal subtree with a given constrained function. The type in focus is existentially quantified inside \texttt{Loc} and should satisfy constraint \texttt{c}. The structure of \texttt{Loc} (shown in Section~\ref{ss:locs}) guarantees that the constraint holds for all types in the family \texttt{fam} and, therefore, for all recursive nodes that can be in focus, hence \texttt{update} can always be applied.

Consider the following example of usage of the interface. Define a pair of mutually recursive datatypes for a rose tree and a forest, where the forest is a list of trees, and the tree is defined as a value in a node and a forest of its children:
\texttt{
\vs
\indent data RoseTree a = RTree a (Forest a)
\vs
\indent data Forest\s\s\s a = Empty | Forest (RoseTree a) (Forest a)
\vspace{0.2cm}
}

Updating the trees can be done through a class:
\texttt{
\vs
\indent class UpdateTree a b where\\
\indent\s\s replaceBy \ann RoseTree a \ra b \ra b\\
\indent\s\s replaceBy \_\s\s\s = id\\
\indent instance UpdateTree a (RoseTree a) where\\
\indent\s\s replaceBy t \_ = t\\
\indent instance UpdateTree a (Forest a)
\vs
}
This replaces a tree node with a given tree, and, for the forests, this leaves the nodes untouched.

For chaining moves and edits, we can follow Yakushev~et~al.~\cite{MuRec2009} and employ  the flipped function composition \comp~and Kleisli composition \kleisli. The latter one is instantiated with the \texttt{Maybe} monad that wraps the result type of the movement functions.
\texttt{
\vs
\indent (\comp) \ann (a \ra b) \ra (b \ra c) \ra (a \ra c)\\
\indent (\kleisli) \ann Monad m \Ra (a \ra m b) \ra (b \ra m c) \ra (a \ra m c)
\vspace{0.2cm}
}

The type family we need to run the example is defined as follows:
\texttt{
\vs
\indent type TreeFam a = '[RoseTree a, Forest a]
\vs
}

Finally, we can use zipper operations with our updating function to traverse and replace a part of a forest:
\texttt{
\vs
\indent *Main> let forest\\
\indent\ind\ind\s = Forest (RTree 'a' \$ Forest (RTree 'b' Empty) Empty)\\
\indent\ind\ind\ind\ind\s\s (Forest (RTree 'x' Empty) Empty)
\vs
\indent *Main> let t = RoseTree 'c' Empty
\vs
\indent *Main> enter @(TreeFam Char) @(UpdateTree Char)\\
\indent\ind\ind\s\comps goDown \kleislis goRight \kleislis goDown\\
\indent\ind\ind\s\kleislis update (replaceBy t)\\
\indent\ind\ind\s\comps leave \comps return \$ forest
\vs
}
This yields the following result:
\texttt{
\vs
\indent Forest (RTree 'a' \$ Forest (RTree 'b' Empty) Empty)\\
\indent\ind\s\s\s (Forest (RTree 'c' Empty) Empty)
\vspace{0.2cm}
}

Our zipper applies to regular datatypes as well. In that case, \texttt{fam} list shall contain a single element. Generally, the interface is flexible enough to allow us to check in any collection of types we are interested in during traversal. However, we demand an updating operation to be a type class function to distinguish the types of the nodes.

\subsection{Locations}
\label{ss:locs}

The location structure consists of a focal subtree, which is one of the mutually recursive nodes of the whole structure of the family of datatypes, and its surrounding context:
\texttt{
\vs
\indent data Loc (r \ann *) (fam \ann [*]) (c \ann * \ra Constraint) where\\
\indent\s\s Loc \ann\hs Family r a fam c \ra Contexts r a fam c\\
\indent\ind\s\s\ra Loc r fam c
\vs
}
The type parameters \texttt{r}, \texttt{fam}, and \texttt{c} in \texttt{Loc} correspond to the root type of the tree, the list of types of nodes to visit, and a constraint imposing restrictions on the types in the list, respectively. Also, the single constructor is existentially quantified over one more type variable, \texttt{a}, for we need to store a type of the focus' parent to be able to move up successively in a tree-like structure. We discuss both term parameters of the constructor of \texttt{Loc} in detail below. 

\subsubsection{Families}

The subtree in a focus is wrapped by the \texttt{Family} datatype. 
The wrapper incapsulates the proofs about a number of important properties of a focus.
We define the \texttt{Family} datatype as a GADT, with embedded 
constraints on its constructor:
\texttt{
\vs
\indent data Family (r \ann *) (a \ann *) (fam \ann [*])\\
\indent\ind\ind\ind (c \ann * \ra Constraint) where\\
\indent\s\s Family \ann\hs (Generic b, In b fam, ZipperI r a b fam c)\\
\indent\ind\ind\s\Ra b \ra Family r a fam c
\vs
}
Though we do not know the type of the focus that is the existential type \texttt{b} in the family, we can obtain enough information about that type to provide the zipper functionality, which is captured by the restrictions above. We guarantee that the type \texttt{b} is a member of the family, and satisfies a set of constraints of the whole zipper interface, collected in the \texttt{ZipperI} constraint: in particular, it ensures that \texttt{a} is the type of the parent node for the node of focus of type \texttt{b} in the tree.

We define the \texttt{In} constraint by means of a type family \texttt{InFam} that is a generalization of \texttt{Equal} defined in Section~\ref{sec:handling-recursion}. The following checks a type for membership of a type-level list that we use to express a family:
\texttt{
\vs
\indent type family InFam (a \ann k) (fam \ann [k]) \ann Bool where\\
\indent\s\s InFam a (a ': fam) = 'True\\
\indent\s\s InFam a (x ': fam) = InFam a fam\\
\indent\s\s InFam a '[]\ind\ind = 'False
\vs
}
The \texttt{In} constraint is defined as
\texttt{
\vs
\indent type In a fam = InFam a fam \tteq 'True
\vspace{0.2cm}
}

Together with the datatype of families, we define a class \texttt{ProofIn} that provides a proof of membership of a family, which generalizes the proof of type equality from Section~\ref{sec:handling-recursion}. The definitions of \texttt{ProofIn} and its auxiliary class \texttt{ProofFam} are given in Figure~\ref{fig:proof-in}. The constraints on the second \texttt{ProofFam} instance, which repeat the same ones from the \texttt{Family} constructor, constitute the proof.
\begin{figure}[t]
\centering
\normalsize
\begin{tabular}{l}
\tt class ProofFam (inFam \ann Bool) (r \ann *) (a \ann *) (b \ann *)\\
\tt\ind\ind\ind\s\s\s (fam \ann [*]) (c \ann * \ra Constraint) where\\
\tt\s\s witness \ann b \ra Maybe (Family r a fam c)
\vs
\tt instance ProofFam 'False r a b fam c where\\
\tt\s\s witness \_ \hs\nths= Nothing\\
\tt instance (Generic b, In b fam, ZipperI r a b fam c)\\
\tt\ind\Ra ProofFam 'True r a b fam c where\\
\tt\s\s witness\s\s\s = Just . Family
\vs
\tt class ProofFam (InFam b fam) r a b fam c\\
\tt\ind\Ra ProofIn r a b fam c\\
\tt instance ProofFam (InFam b fam) r a b fam c\\
\tt\ind\Ra ProofIn r a b fam c
\end{tabular}
\caption{Proof of membership of a family of datatypes.}
\label{fig:proof-in}
\end{figure}

\subsubsection{Contexts}

When we focus on a particular node in a data structure, having the surrounding context of that node is enough to reconstruct the entire structure. The context for the tree's location has the shape of the original structure of that tree but with one hole at the place of its focus, whence it is sometimes called a \emph{one-hole context}. The context can be expressed as a stack (\texttt{Contexts} below), where each frame \texttt{Context} corresponds to the particular node with a hole: it ascends from the focal node keeping its siblings, the siblings of its parent, and until it reaches the root node, through all levels in the tree. So the stack of contexts essentially reflects the track of the movement in the structure.
\texttt{
\vs
\indent data Contexts (r \ann *) (a \ann *) (fam \ann [*])\\
\indent\ind\ind\ind\s\s (c \ann * \ra Constraint) where\\
\indent\s\s CNil \ann\hs Contexts a a fam c\\
\indent\s\s Ctxs \ann\hs (Generic a, In a fam, ZipperI r x a fam c)\\
\indent\ind\s\s\s\Ra Context fam a \ra Contexts r x fam c\\
\indent\ind\s\s\s\ra Contexts r a fam c
\vs
}
This has the shape similar to the previously defined \texttt{Loc} and \texttt{Family} datatypes: it keeps the types of the root and of the immediate parent of the focal node (of the union with the focal subtree when that plugs the hole)---as ensured by sharing that type with \texttt{Family} in the \texttt{Loc} constructor. The \texttt{ZipperI} constraint with the type \texttt{x} of the previous context frame here indicates that the constraint for the zipper holds after plugging the hole, so all the properties, conversely, can be proved by induction for the focus type when it moves down in the tree adding new contexts onto the stack---and the \texttt{CNil} constructor for an empty context with the \texttt{r} and \texttt{a} types equal is the inductive basis in that proof. Note that the type of the current focus is not reflected in the \texttt{Contexts} datatype, as we do not need that.

McBride~\cite{McBride2001} studies a relation between the one-hole context definition and \emph{partial differentiation} from calculus: he shows that the type of the context for an arbitrary (regular) type can be derived mechanically from that type by means of a list of differentiation \emph{rules} that serve as formulaic instructions for computing the type in type-level programming. Yakushev~et~al.~\cite{MuRec2009} then demonstrate that his method can be generalized for mutually recursive datatypes. We adapt that technique to \textsf{generics-sop}, and now need a few auxiliary type-level functions to implement the computation of the context type. Those functions, defined recursively via type families, provide algebraic operations for lists of types (which we regard as sums and products of types): addition and multiplication. Specifically, we define addition \texttt{.++} of two sums of products (SOP) of types, multiplication \texttt{.*} of a SOP by a single type, and multiplication \texttt{.**} of a SOP by a product of types, as shown in Figure~\ref{fig:type-arithmetic}.
\begin{figure}[h]
\centering
\normalsize
\begin{tabular}{l}
\textbf{SOP addition}
\vs
\tt type family (.++) (xs \ann [[*]]) (ys \ann [[*]]) \ann [[*]] where\\
\tt\s\s (x ': xs) .++ ys = x ': (xs .++ ys)\\
\tt\s\s '[]\ind\s\s\s .++ ys = ys\\
\tt infixr 6 .++
\vspace{0.3cm}\\
\textbf{SOP-by-type multiplication}
\vs
\tt type family (.*) (x \ann *) (ys \ann [[*]]) \ann [[*]] where\\
\tt\s\s x .* (ys ': yss) = (x ': ys) ': (x .* yss)\\
\tt\s\s x .* '[]\ind\ind\s = '[]\\
\tt infixr 7 .*
\vspace{0.3cm}\\
\textbf{SOP-by-product multiplication}
\vs
\tt type family (.**) (xs \ann [*]) (ys \ann [[*]]) \ann [[*]] where\\
\tt\s\s (x ': xs) .** yss = x .* (xs .** yss)\\
\tt\s\s '[]\ind\s\s\s .** yss = yss\\
\tt infixr 7 .**
\end{tabular}
\caption{Algebraic operations on type-level sums and products.}
\label{fig:type-arithmetic}
\end{figure}

The addition operation just appends two type-level lists of lists (sums of products), multiplication by a type adds the type to the head of each inner list of the sum (here we see multiplication of a product and the distributive property of multiplication over addition, just as in arithmetic of numbers), and multiplication by a product appends the list to the head of each inner product of the sum. Again, kind \texttt{[*]} here denotes products, and \texttt{[[*]]} denotes sums (of products), so the relation with arithmetic of numbers in these definitions becomes more clear if one realizes that an empty sum \texttt{'[] \ann [[*]]} corresponds to $1$, and an empty product \texttt{'[] \ann [*]} corresponds to $0$. We also specify, through the \texttt{infixr} declaration, that multiplication has a higher priority than addition.

Using the defined operations, we can implement differentiation of a product of types. The definition of differentiation shown in Figure~\ref{fig:diff-prod} resembles its analogue from calculus, but it is now generalized for the setting of families of datatypes: the differentiation of the single type reflected by a one-element list here results in $0$ (reflected by \texttt{'[]}) if that is not in the family and hence is regarded as a constant, otherwise it results in $1$. When differentiation gives $1$, it is actually the hole, which we express by defining the unit type \texttt{Hole}. Reflecting this type in the context is helpful when we traverse the context representation to plug the hole. We use the empty type \texttt{End} to distinguish the case when the hole is found at the end of the list, in order not to add that into the result twice. The sum \texttt{'[ '[]]} represents a unit type that is exactly $1$. We also use type-level \texttt{If} that returns its second argument for \texttt{'True}, and the third one otherwise. We do not give its definition here, as it is straightforward.
\begin{figure}[t]
\centering
\normalsize
\begin{tabular}{l}
\tt data Hole = Hole\\
\tt data End
\vs
\tt type family DiffProd (fam \ann [*]) (xs \ann [*]) \ann [[*]] where\\
\tt\s\s DiffProd fam '[]\ind\s\s\s = '[]\\
\tt\s\s DiffProd fam '[x]\ind\s\s = If (InFam x fam) '[ '[Hole]] '[]\\
\tt\s\s DiffProd fam '[End, x] = If (InFam x fam) '[ '[]]\ind\s '[]\\
\tt\s\s DiffProd fam (x ': xs)\\
\tt\ind = Hole .* xs .** DiffProd fam '[End, x]  .++\\
\tt\ind\ind\ind\s\s x\s\s .*\s\s DiffProd fam xs
\end{tabular}
\caption{Differentiation of a product of types.}
\label{fig:diff-prod}
\end{figure}

The following completes the computation of the context type:
\texttt{
\vs
\indent data ConsN = F | N ConsN | None\\
\indent\s\s deriving Eq
\vs
\indent type family ToContext (n \ann ConsN) (fam \ann [*])\\
\indent\ind\ind\ind\ind\ind\s\s (code \ann [[*]]) \ann [[*]] where\\
\indent\s\s ToContext n fam '[] = '[]\\
\indent\s\s ToContext n fam (xs ': xss)\\
\indent\ind = Proxy n .* DiffProd fam xs .++ ToContext ('N n) fam xss
\vs
}
The type family \texttt{ToContext} derives the type of the context of a datatype performing differentiation of a sum on its code. Since each product from the code matches a sum of multiple products in the context, it is helpful for each product of the context representation, to keep the index of its matching constructor of the datatype. We store the index in the datatype \texttt{ConsN} adding that to the head of each product but wrapped by \texttt{Proxy} because we use \texttt{ConsN} promoted to a kind in the type family, while the products contain types of kind \texttt{*}. The constructors \texttt{F} and \texttt{N} denote ``first'' and ``next'', respectively, and the special constructor \texttt{None} will be used further to indicate failure of matching indices.

We finally define \texttt{Context} as a newtype wrapping the result of the computation, as it allows GHC to perform type inference for the context type, where it is possible, to avoid extra type applications for defining the zipper operations.
\texttt{
\vs
\indent type CtxCode  fam a = ToContext 'F fam (Code a)
\vs
\indent newtype Context fam a = Ctx \{ctx \ann SOP I (CtxCode fam a)\}
\vs
}
The \texttt{CtxCode} type is the computed type of the context for the given code of a datatype. We will use this type synonym further when defining constraints for functions providing the generic zipper interface.

\subsection{Implementing the zipper interface}
\label{ss:zip-impl}

We now can implement the interface functions of the zipper, which we have previously described. We only demonstrate the implementation of the \texttt{goDown} function here. This shows the idea of how we can use our idiom for defining the zipper functions, and the source code with the full implementation of the zipper interface is available at our \textsf{GitHub} repository\footnote{\url{https://github.com/Maryann13/Zipper}}.

To move focus down to the leftmost child of the current focal node in the tree, we should analyze the focal subtree's representation to find its first immediate child, and compute its respective context. The following definition of \texttt{goDown} uses two auxiliary functions: \texttt{toFirst} and \texttt{toFirstCtx}.
\texttt{
\vs
\indent goDown \ann Loc a fam c \ra Maybe (Loc a fam c)\\
\indent goDown (Loc (Family t) cs)\\
\indent\s\s = case toFirst t of\\
\indent\ind\s\s Just t' \ra Just \$ Loc t' (Ctxs (toFirstCtx t) cs)\\
\indent\ind\s\s\_\ind\s\s\s\hs\ra Nothing
\vs
}
The function \texttt{toFirst} returns its result in the \texttt{Maybe} monad, and may return \texttt{Nothing}, if the focal node has no children, that is, we currently focus on the leaf node and cannot go down. The function \texttt{toFirstCtx} should not fail: if we can move, it computes the context that matches the leftmost subtree selected from the focus' children.

\begin{figure}[t]
\centering
\normalsize
\begin{tabular}{l}
\tt toFirst \ann\hs\fa fam c r a. (Generic a, ToFirst r a fam c)\\
\tt\ind\ind\Ra a \ra Maybe (Family r a fam c)\\
\tt toFirst t = appToNP @AllProof toFirstNP \$ unSOP \$ from t
\vspace{0.3cm}\\
\bf Proof
\vs
\tt class\ind All (ProofIn r a fam c) xs \Ra AllProof r a fam c xs\\
\tt instance All (ProofIn r a fam c) xs \Ra AllProof r a fam c xs
\vs
\tt type ToFirst r a fam c = All (AllProof r a fam c) (Code a)
\vspace{0.3cm}\\
\bf Processing products
\vs
\tt toFirstNP \ann\hs\fa fam c r a xs. All (ProofIn r a fam c) xs\\
\tt\ind\ind\s\s\Ra NP I xs \ra Maybe (Family r a fam c)\\
\tt toFirstNP (I (x \ann b) :* xs)\\
\tt\s\s = witness @(InFam b fam) x `mplus` toFirstNP xs\\
\tt toFirstNP Nil = Nothing
\end{tabular}
\caption{Implementation of \texttt{toFirst}.}
\label{fig:toFirst}
\end{figure}

\subsubsection{toFirst}

We first implement the function \texttt{toFirst}. Its full definition is displayed in Figure~\ref{fig:toFirst}. The \texttt{toFirst} function uses the higher-oredered function \texttt{appToNP} that unwraps the product from \texttt{NS} and applies the given function to that product. The function \texttt{toFirstNP} is defined recursively using the proof we have defined for families: it traverses the product until it finds the first recursive node by means of \texttt{witness} that for the node \texttt{x} of unknown type \texttt{b}, witnesses its membership of the family, or else returns \texttt{Nothing}. To provide the proof for the representation code of a datatype, we define the proof for all products in a sum, and pass this proof through explicit type application to \texttt{appToNP} which takes a constrained function. The \texttt{appToNP} function is defined similarly to \texttt{subtermsNS} from Section~\ref{sec:recursion-problem}, and we omit its definition here.

\subsubsection{toFirstCtx}

The definition of \texttt{toFirstCtx} is more complicated, as it performs the computation of the context. The implementation comprises several steps including type- and term-level programming. In the following, we systematically construct the context representation from the given generic representation of a datatype.

At first, for a datatype's given constructor represented by \texttt{NP}, we build its matching constructor of the context. All constructors of the context have the same shape as the constructors of its respective datatype but with a hole at one of points of recursion---we are now computing the context with the first recursive node deleted. Assuming that we have the product type for the context computed, we can compute the product by matching on that type:
\texttt{
\vs
\indent class FromFstRec (ys \ann [*]) (xs \ann [*]) where\\
\indent\s\s fromFstRec \ann NP I xs \ra NP I ys
\vs
\indent instance FromFstRec (Hole ': xs) (x ': xs) where\\
\indent\s\s fromFstRec (\_ \hs\nths:* xs) = I Hole :* xs\\
\indent instance FromFstRec ys xs\\
\indent\ind\Ra FromFstRec (x ': ys) (x ': xs) where\\
\indent\s\s fromFstRec (x :* xs) = x\ind\s\s :* fromFstRec xs\\
\indent instance FromFstRec '[] '[] where\\
\indent\s\s fromFstRec \_\ind\ind\s \hs\nths= Nil
\vs
}
Note that the first type parameter in the \texttt{FromFstRec} class is the index type list of the result \texttt{NP}---this order of type variables remains for type application through which we will supply the computed type.

Once we have constructed the product, we have to build the sum representing the choice of that product. If we have the index of the chosen constructor for the datatype, the one that we find for its context can be computed as follows:
\texttt{
\vs
\indent type family CtxConsN (xss \ann [[*]]) (n \ann ConsN) \ann ConsN where\\
\indent\s\s CtxConsN '[]\ind\ind\ind\ind\ind\s\s\s n = 'None\\
\indent\s\s CtxConsN ((Proxy n \s': xs) ': xss) n = 'F\\
\indent\s\s CtxConsN ((Proxy n' ': xs) ': xss) n = 'N (CtxConsN xss n)
\vs
}
The list \texttt{xss} here is expected to be the context code, which this traverses until the first product storing the constructor index equal to the given one, i.~e., the context's first constructor matching with the chosen constructor of the datatype.

To construct the sum with the computed index and product, we again need a proof to witness that the product is type-consistent with the constructor choice. To choose the constructor from the context code, we can adopt \textsf{generics-sop}'s \emph{injections}\footnote{The actual definition of the type of injections in \textsf{generics-sop} slightly differs from this. We adapt that for presentation.}:
\texttt{
\vs
\indent injections \ann \fa xs f. SListI xs \Ra NP (Inj f xs) xs
\vs
\indent newtype Inj f xs a = Inj \{apInj \ann f a \ra K (NS f xs) a\}
\vs
}
For \texttt{f} instantiated to \texttt{NP I} and \texttt{xs} to be the sum of products reflecting a representation code, \texttt{injections} creates a product of all constructor choices that inject appropriate constructor arguments into each sum. We can use injections to choose the one that matches the obtained index.

We now can witness the choice using the proof of type equality we have defined in Section~\ref{sec:handling-recursion}. In the following definition, \texttt{f} is supposed to be instantiated to \texttt{Inj (NP I) xss} where \texttt{xss} reflects the code of the context\footnote{This might be simplified by using a singleton type for \texttt{ConsN} instead of defining a type class function. However, when using a singleton, the recursive definition of \texttt{toFirstCtx} we give further requires a constraint on its function signature that leads to a nonterminating computation.}:
\texttt{
\vs
\indent class\ind Proof (Equal a b) (f a) (f b) \Ra ProofF f a b\\
\indent instance Proof (Equal a b) (f a) (f b) \Ra ProofF f a b
\vs
\indent class ConsNInj (n \ann ConsN) (ys \ann [*]) where\\
\indent\s\s consNInj \ann All (ProofF f ys) xss \Ra NP f xss \ra f ys
\vs
\indent instance ConsNInj n xs \Ra ConsNInj ('N n) xs where\\
\indent\s\s consNInj (\_ :* xss) = consNInj @n xss\\
\indent\s\s consNInj Nil\ind\s\s\s\hs \hs\ths\tths= impossible\\
\indent instance ConsNInj 'F xs where\\
\indent\s\s consNInj ((xs \ann f xs) :* \_)\\
\indent\ind = fromMaybe impossible \$ witnessEq @(Equal xs ys) xs\\
\indent\s\s consNInj Nil = impossible\\
\indent instance ConsNInj 'None xs where\\
\indent\s\s consNInj \_\s\s\s \hs\nths= impossible
\vs
\indent impossible \ann a\\
\indent impossible =  error "impossible"
\vs
}
As long as the constructor index and product type are computed correctly, the proof should never fail (\texttt{impossible}). And when it passes, this ensures by type check that the constructor choice for the given product type is faithful.

Finally, we define a function that applies the injection and returns the constructed context for the given product, representing its constructor arguments, and index of that constructor. The type of \texttt{injections} below will be inferred from the return type of the context.
\texttt{
\vs
\indent type AppInj n xs ctx =  (ConsNInj n xs, SListI ctx,\\
\indent\ind\ind\ind\ind\ind\ind All (ProofF (Inj (NP I) ctx) xs) ctx)
\vs
\indent appInjCtx \ann \fa n xs fam a. AppInj n xs (CtxCode fam a)\\
\indent\ind\ind\s\s \Ra NP I xs \ra Context fam a\\
\indent appInjCtx np\\
\indent\s\s = Ctx \$ SOP \$ unK \$ apInj (consNInj @n injections) np
\vspace{0.2cm}
}

The definition of \texttt{toFirstCtx} can now be given using the defined functions \texttt{appInjCtx} and \texttt{fromFstRec}. The following makes use of a type-level function \texttt{FstRecToHole} to compute the product type by replacing the first recursive occurrence in the given datatype's product list with type \texttt{Hole}. Its definition is straightforward, and is omitted here.
\texttt{
\vs
\indent toFirstCtx \ann \fa fam c a. (Generic a, ToFirstCtx fam a)\\
\indent\ind\ind\s\s\s \Ra a \ra Context fam a\\
\indent toFirstCtx t = toFirstCtxNS @'F \$ unSOP \$ from t
\vs
\indent toFirstCtxNS \ann \fa n fam a xss. ToFirstCtx' fam a n xss\\
\indent\ind\ind\ind\s \Ra NS (NP I) xss \ra Context fam a\\
\indent toFirstCtxNS (S ns) = toFirstCtxNS @('N n) ns\\
\indent toFirstCtxNS (Z (np \ann NP I xs))\\
\indent\s\s = appInjCtx @(CtxConsN (CtxCode fam a) n) \$\\
\indent\ind\ind I (Proxy @n) :* fromFstRec @(FstRecToHole fam xs) np
\vs
\indent type ToFirstCtx fam a = ToFirstCtx' fam a 'F (Code a)
\vs
}
The \texttt{ToFirstCtx'} constraint here is a complex constraint for use of \texttt{appInjCtx} and \texttt{fromFstRec}, which involves extra type classes and a bit of type-level programming to deduce those particular constraints. Its definition is given in the extended version of the paper in Technical Report. We omit this here for reasons of space.

We have established the mechanism of translation, which is cumbersome but verifying, via the proof, that the constructed context will have the correct type for any given datatype and family. The other functions in the zipper interface can be implemented according to this technique.


\section{Related work}
\label{sec:related-work}

There are many works that contribute to datatype-generic programming. Rodriguez et al.~\cite{Rodriguez2008} and Magalh{\~{a}}es and L{\"{o}}h~\cite{MagLoeh2012} review a number of existing approaches and provide their detailed comparison in various aspects. There are several generic views that use certain forms of the fixed point operator to express recursion in a datatype structure~\cite{VanNoort2008,MuRec2009,Jansson1997,Loeh2011}. And there are a number of approaches that do not make use of fixed points~\cite{Chakravarty2009,Cheney2002,Magalhaes2010,Weirich2006}, but explicitly encode recursion in the datatype representation. The SOP view~\cite{VriLoeh2014}, which we use to demonstrate our technique, is an approach to generic programming that does not reflect recursive positions in the generic representation of a datatype. This approach uses heterogeneous lists of types to encode sums and products in the generic representation.

The idea similar to SOP has been proposed by Kiselyov~et~al.~\cite{Kiselyov2004} in their \textsf{HList} library for strongly typed heterogeneous collections. In the paper, the authors also discuss problems connected with overlap, which they use for access operations. Another Haskell extension, functional dependencies, is applied to restrict overlap in type equality there, which resembles our solution.

Morris and Jones~\cite{Morris2010} introduce the type-class system \textsf{ilab}, based on the Haskell 98 class system, with a new feature called ``instance chains''. This enables one to control overlap by using an explicit syntax in instance declarations. The approach resembles if-else chains. But the use of instance chains and local use of overlap leave code error-prone as a consequence of type class openness. Closed type families~\cite{Eisenberg2014} were recently introduced in Haskell to solve the overlap problem.

Several works show how to define the Zipper~\cite{Huet1997} generically for regular~\cite{HiJeLo2004,McBride2001} and mutually recursive~\cite{MuRec2009} types using fixed-point generic views. Adams~\cite{Adams2010} defines a generic zipper for heterogeneous types.



\section{Conclusion}
\label{sec:conclusion}

Defining generic functions, which consider recursion points, is easy within generic views that are explicit about recursion in the datatype representation. Not so much otherwise. Although, there are some approaches that address the problem by means of global or local overlaps. We have developed the technique that allows one to define generic functions that treat recursion without its explicit encoding and without overlap. 

We have demonstrated that the method suits for advanced recursive schemes, such as the generic zipper interface. Also, it supports families of mutually recursive datatypes. 

Arguably, it is still easier to treat recursion when ``explicit'' encoding is used. On the other hand, we believe, once the problem of handling recursion is shown to be manageable, new generic universes shall emerge, not worrying about the recursion support, but rather focusing on other generic programming problems.

%
% ---- Bibliography ----
%
% BibTeX users should specify bibliography style 'splncs04'.
% References will then be sorted and formatted in the correct style.
%
\bibliographystyle{splncs04}
\bibliography{lncs-biblio}
%
\end{document}
