%% For double-blind review submission, w/o CCS and ACM Reference (max submission space)
\documentclass[sigplan,review,anonymous]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For double-blind review submission, w/ CCS and ACM Reference
%\documentclass[sigplan,review,anonymous]{acmart}\settopmatter{printfolios=true}
%% For single-blind review submission, w/o CCS and ACM Reference (max submission space)
%\documentclass[sigplan,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For single-blind review submission, w/ CCS and ACM Reference
%\documentclass[sigplan,review]{acmart}\settopmatter{printfolios=true}
%% For final camera-ready submission, w/ required CCS and ACM Reference
%\documentclass[sigplan]{acmart}\settopmatter{}


%% Conference information
%% Supplied to authors by publisher for camera-ready submission;
%% use defaults for review submission.
\acmConference[PL'18]{ACM SIGPLAN Conference on Programming Languages}{January 01--03, 2018}{New York, NY, USA}
\acmYear{2018}
\acmISBN{} % \acmISBN{978-x-xxxx-xxxx-x/YY/MM}
\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}

%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission;
%% use 'none' for review submission.
\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2018}           %% If different from \acmYear

%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
\citestyle{acmauthoryear}  %% For author/year citations
%\citestyle{acmnumeric}     %% For numeric citations
%\setcitestyle{nosort}      %% With 'acmnumeric', to disable automatic
                            %% sorting of references within a single citation;
                            %% e.g., \cite{Smith99,Carpenter05,Baker12}
                            %% rendered as [14,5,2] rather than [2,5,14].
%\setcitesyle{nocompress}   %% With 'acmnumeric', to disable automatic
                            %% compression of sequential references within a
                            %% single citation;
                            %% e.g., \cite{Baker12,Baker14,Baker16}
                            %% rendered as [2,3,4] rather than [2-4].


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Note: Authors migrating a paper from PACMPL format to traditional
%% SIGPLAN proceedings format must update the '\documentclass' and
%% topmatter commands above; see 'acmart-sigplanproc-template.tex'.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%% Some recommended packages.
\usepackage{booktabs}   %% For formal tables:
                        %% http://ctan.org/pkg/booktabs
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption


\newcommand{\s}{$\hphantom{~}$}
\newcommand{\ind}{\s\s\s\s}
\newcommand{\Ra}{$\Rightarrow$\s}
\newcommand{\ra}{$\rightarrow$\s}
\newcommand{\vs}{\vspace{0.2cm}\\}
\newcommand{\fa}{$\forall$}


\begin{document}

%% Title information
\title[Short Title]{Full Title}         %% [Short Title] is optional;
                                        %% when present, will be used in
                                        %% header instead of Full Title.
%\titlenote{with title note}             %% \titlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'
%\subtitle{Subtitle}                     %% \subtitle is optional
%\subtitlenote{with subtitle note}       %% \subtitlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'


%% Author information
%% Contents and number of authors suppressed with 'anonymous'.
%% Each author should be introduced by \author, followed by
%% \authornote (optional), \orcid (optional), \affiliation, and
%% \email.
%% An author may have multiple affiliations and/or emails; repeat the
%% appropriate command.
%% Many elements are not rendered, but should be provided for metadata
%% extraction tools.

%% Author with single affiliation.
\author{First1 Last1}
%\authornote{with author1 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
  \position{Position1}
  \department{Department1}              %% \department is recommended
  \institution{Institution1}            %% \institution is required
  \streetaddress{Street1 Address1}
  \city{City1}
  \state{State1}
  \postcode{Post-Code1}
  \country{Country1}                    %% \country is recommended
}
\email{first1.last1@inst1.edu}          %% \email is recommended

%% Author with single affiliation.
\author{First2 Last2}
%\authornote{with author2 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
  \position{Position2}
  \department{Department2}             %% \department is recommended
  \institution{Institution2}           %% \institution is required
  \streetaddress{Street2 Address2}
  \city{City2}
  \state{State2}
  \postcode{Post-Code2}
  \country{Country2}                   %% \country is recommended
}
\email{first2.last2@inst2.com}         %% \email is recommended


%% Abstract
%% Note: \begin{abstract}...\end{abstract} environment must come
%% before \maketitle command
\begin{abstract}
Many of the commonly used today libraries for datatype-generic programming offer a fixed-point view on datatypes to express the recursive structure. Some approachs based on sums of products, however, do not use a fixed point. Those views therefore allow for generic functions that do not require to look at the recursive knots in the datatype representation, but raise issues when it needs to deal with recursion. A known unwelcome solution is use of overlapping instances. We present a technique that uses closed type families to allow us to eliminate overlapping for handling recursion. Moreover, we show that our idiom allows for families of mutually recursive datatypes.

The \textsf{generics-sop} library is an approach to representing data using $n$-ary sums and products that both are list-like structures, which is different from the classical view where datatypes are expressed by combinations of separate binary sums and products, and it does not encode recursive knots explicitly as with the fixed-point view. We choose this approach as a case study to demonstrate our solution.
\end{abstract}


%% 2012 ACM Computing Classification System (CSS) concepts
%% Generate at 'http://dl.acm.org/ccs/ccs.cfm'.
\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10011007.10011006.10011008</concept_id>
<concept_desc>Software and its engineering~General programming languages</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10003456.10003457.10003521.10003525</concept_id>
<concept_desc>Social and professional topics~History of programming languages</concept_desc>
<concept_significance>300</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Software and its engineering~General programming languages}
\ccsdesc[300]{Social and professional topics~History of programming languages}
%% End of generated code


%% Keywords
%% comma separated list
\keywords{Datatype-generic programming, Sums of products, Recursion, Overlapping instances, Closed type families, Zippers, Mutually recursive datatypes, Haskell}  %% \keywords are mandatory in final camera-ready submission


%% \maketitle
%% Note: \maketitle command must come after title commands, author
%% commands, abstract environment, Computing Classification System
%% environment and commands, and keywords command.
\maketitle


\section{Introduction}
\label{sec:introduction}

A classical way to generically view data is to represent constructors as chains of nested binary sums, and constructor arguments as chains of nested binary products~\citep{VanNoort2008, MuRec2009, Cheney2002, Magalhaes2010, Loeh2004}\nocite{Rodriguez2008}\nocite{Magalhaes2012}. \citet{VriLoeh2014} describe a different sum-of-products approach to representing data using $n$-ary sums and products that both are lists of types, a sum of products is thus a list of lists of types. They call their view SOP that stands for a ``sum of products''---this is implemented in the \textsf{generics-sop} library and is based on several relatively recent extensions to the Haskell type system, such as \emph{data kinds} and \emph{kind polymorphism}~\citep{Yorgey2012}, \emph{constraint kinds}, and \emph{GADTs}~\cite{Schrijvers2009}. Using these Haskell features, the library provides the generic view and equips it with a rich collection of high-level traversal combinators, such as for constructing sums and products, collapsing to homogeneous structures, and application, which are an expressive instrument for defining generic functions in a more succinct and high-level style compared to the classical binary sum-of-products views.

There are many generic functions that deal with the recursive knots, when traverse the structure of datatypes. Some of the most general examples are \emph{maps}~\citep{Magalhaes2010} and \emph{folds}~\citep{Meijer1991, MuRec2009}, more advanced one is a \emph{zipper}~\citep{Huet1997, MuRec2009, HiJeLo2004, Adams2010}. For handling recursion, several generic programming approachs use different forms of a fixed-point operator and express datatypes in the form of polynomial functors closed under fixed points~\citep{VanNoort2008, MuRec2009, Jansson1997, Loeh2011}\nocite{MagLoeh2012}. The SOP view allows to easily define functions that do not need to specially process recursive occurences. But for those that do need it, it normally does not allow.

One possible solution is to construct a more specific universe modifying the SOP core by explicitly encoding recursive positions using a fixed point. The fixed-point approach can be combined with SOP~\citep{VriLoeh2014}, but doing so makes that more complicated. Besides, such a decision may lead to need for additional conversions between the views. Our method makes it possible to define functions that need access to recursive occurences within the SOP view without modifying it anyhow. However, the definitions are still quite verbose.

Another known solution is use of overlapping instances. This is unwelcome, as involving overlapping instances complicates reasoning about the program semantics, makes it unstable because code with overlapping instances can indirectly change the behavior, if one adds more specific instances into scope by importing a new module. Furthermore, GHC does not reject ambiguous overlaps where neither of instance declarations is more specific than the other and does not even warn about ambiguity before attempting to use it at a type class function call site. This is also crucial in the security setting when code is compiled as safe, as GHC does not capture unsafe overlaps by detecting the presence of overlapping declarations and marking the module unsafe~\citep{sh-overlapping}. Hence, the undesirable effect of overlapping instances becomes a problem in the setting of Safe Haskell. \citet{Kiselyov2004} show how to localize overlapping for access operations in a systematic way. Using \textit{closed type families}~\citep{Eisenberg2014}, we introduce an idiom that allows us to completely eliminate overlapping for handling recursion.

We believe that our idea is suitable for a number of different sum-of-products approachs that do not exploit a fixed point---so there the described problem appears. We choose the \textsf{generics-sop} approach as a case study because we think it is a widely applicable library based on the interesting ideas for generic programming, and it relies on GHC's recent extensions.

To demonstrate our approach, we give several examples. Another interesting result of our work, which contributes to \textsf{generics-sop}, is an interface we provide for generic functions: the type class instances with them do not need to be manually declared, as we define the instances on the generic representation of datatypes.

\paragraph{Contributions} This paper makes the following contributions:
\begin{itemize}
\item We introduce an idiom that allows to exclude use of overlapping instances for handling recursion in a number of sum-of-products approachs to datatype-generic programming that do not express recursive positions through a fixed point.
\item We present our idea by giving several examples of generic functions, particularly the generic zipper for mutually recursive datatypes, using the \textsf{generics-sop} view.
\item We provide a convenient interface for generic functions: there is no need to manually declare type class instances for using them.
\end{itemize}

\paragraph{Organization} The paper is organized as follows. In Section~\ref{sec:sop-problem}, we introduce the SOP view concepts and demonstrate the problem by a short example. In Section~\ref{sec:handling-recursion}, we show our solution using closed type families and accompany it with one more example of a generic function adapting the idea. In Section~\ref{sec:generic-zipper}, we present an advanced example of the generic zipper for mutually recursive datatypes. In Section~\ref{sec:related-work}, we review related work, and we conclude in Section~\ref{sec:conclusion}.


\section{The SOP universe and the problem}
\label{sec:sop-problem}

In this section, we first review the SOP view on data describing its basic concepts to introduce the terminology we are using. After this introduction, we discuss the problem with handling recursion by generic functions and illustrate it with a short example.

\subsection{The SOP view}

We first explain the terminology we borrow from SOP\nocite{Loeh2015}\nocite{generics-sop} and use throughout the paper. The main idea of the SOP view is that a datatype is isomorphic to the sum of products of its code whose kind is a list of lists of types---it makes use of the \textsf{DataKinds} extension that enables datatype definitions to be promoted to kinds. SOP expresses this using a \texttt{Code} type family:
\texttt{
\vs
\textbf{type family} Code (a :: *) :: [[*]]
\vs
}
An $n$-ary sum and an $n$-ary product are therefore modelled as type-level heterogeneous lists: the inner list is an $n$-ary product that provides a sequence of constructor arguments depending on the constructor chosen; the outer list, an $n$-ary sum, corresponds to a choice between different constructors.

For example, the code for the datatype of binary trees
\texttt{
\vs
\textbf{data} Tree a = Leaf a\\
\ind\ind\ind | Node (Tree a) (Tree a)
\vs
}
is expected to be as follows:
\texttt{
\vs
\textbf{type instance} Code (Tree a) =\\
\ind '[ '[a]\\
\ind\s , '[Tree a, Tree a]\\
\ind\s ]
\vspace{0.2cm}
}

\begin{figure}[t]
\begin{tabular}{l}
\tt \textbf{data} NP (f :: k \ra *) (xs :: [k]) \textbf{where}\\
\tt\s\s Nil\s\s :: NP f '[]\\
\tt\s\s (:*) :: f x \ra NP f xs \ra NP f (x ': xs)
\vs
\tt \textbf{data} NS (f :: k \ra *) (xs :: [k]) \textbf{where}\\
\tt\s\s Z :: f x \ra NS f (x ': xs)\\
\tt\s\s S :: NS f xs \ra NS f (x ': xs)
\vs
\hline
\end{tabular}
\caption{Datatypes for $n$-ary sums and products.}
\label{fig:ns-np}
\end{figure}

A type of promoted lists has no inhabitants, so the universe provides datatypes to operate on $n$-ary sums and products as on terms. As shown in Figure~\ref{fig:ns-np}, the datatypes \texttt{NS} for an $n$-ary sum and \texttt{NP} for an $n$-ary product are defined as GADTs and are indexed~\citep{HiJeLo2004} by a promoted datatype of lists. The universe defines these with built-in functor application, where the functor is some type constructor. Thus, each component of \texttt{NS} and \texttt{NP} is given by mapping a corresponding type in the type-level list. The definitions of \texttt{NS} and \texttt{NP} both are kind polymorphic. The index list allows to contain types of arbitrary kind \texttt{k}, as applying the functor \texttt{f} turns \texttt{k} to \texttt{*}.

As basic instantiation types of \texttt{f}, SOP defines an identity functor \texttt{I} that is type-level equivalent for \texttt{id}, and a constant functor \texttt{K}, for \texttt{const}:
\texttt{
\vs
\textbf{newtype} I (a :: *)\ind\ind\s\s = I \{unI :: a\}\\
\textbf{newtype} K (a :: *) (b :: k) = K \{unK :: a\}
\vs
}
Whereas instantiated with \texttt{I}, the product is a direct heterogeneous list of types, with \texttt{K a}, it is essentially homogeneous. An example value of a product for \texttt{I} looks thus:
\texttt{
\vs
I 5 :* I True :* Nil :: NP I '[Int, Bool]
\vspace{0.2cm}
}

A clear idea underlies the sum definition. The constructor \texttt{S} of a sum skips the first element of an $n$-element index list giving an index in a list that has $n+1$ elements, while \texttt{Z} stores the payload of type \texttt{f x}. For example, the following chooses the third element of a sum:
\texttt{
\vs
S (S (Z (I 3))) :: NS I '[Char, Bool, Int, Bool]
\vs
}
The sum constructors are similar to Peano numbers, so the choice from a datatype's sum of products matches the index of its particular constructor in the index list and gives the product representing arguments of that constructor.

With the representation datatypes \texttt{NS} and \texttt{NP}, SOP defines a \texttt{Generic} class with conversion functions \texttt{from} and \texttt{to} to witness the isomorphism:
\texttt{
\vs
\textbf{type} Rep a = SOP I (Code a)
\vs
\textbf{class} All SListI (Code a) \Ra\\
\s\s\s\s\s\s Generic (a :: *) \textbf{where}\\
\s\s \textbf{type} Code a :: [[*]]\\
\s\s from :: a \ra Rep a\\
\s\s to\s\s\s :: Rep a \ra a
\vs
}
The sum of products \texttt{SOP f} is a newtype for \texttt{NS (NP f)}, indexed by a type-level list of lists, and the structural representation \texttt{Rep} of a datatype is a type synonym for a \texttt{SOP I} of its code. The functions \texttt{from} and \texttt{to} perform a shallow conversion of the datatype topmost layer---it does not recursively translate the constructor arguments.

The \texttt{All SListI} constraint in the \texttt{Generic} class definition is supposed to be satisfied, and an understanding of this detail is not necessary to understand the paper, but we will next use an understanding of the constraint \texttt{All} specifying that a particular constraint holds for each element in a list of types. Using constraints as types of a special kind \texttt{Constraint}, hence they can appear as type parameters, is allowed by the \textsf{ConstraintKinds} language extension.

The \texttt{Generic} class definition in the \textsf{generics-sop} library uses a \textit{generic generic programming} technique~\citep{MagLoeh2014} to create the instance for a particular datatype automatically using the internal \textsf{GHC.Generics} representation. Alternatively, \textsf{generics-sop} allows to produce the instances using Template Haskell~\citep{SheardSPJ2002}.

\subsection{Problem with handling recursion}

Let us illustrate the problem by giving a short example. The \textsf{QuickCheck}~\citep{Claessen2011}, a library for automatic testing of Haskell code, using the \textsf{GHC.Generics} view, defines a helper function \texttt{subterms} that takes a term and obtains a list of all its immediate subterms that are of the same type as the given term, that is, all the recursive positions in the term structure. To implement such a function using the SOP view, we have to say something like this:
\texttt{
\vs
subterms :: Generic a \Ra a \ra [a]\\
subterms t = subtermsNS (unSOP \$ from t)
\vs
subtermsNS :: NS (NP I) xss \ra [a]\\
subtermsNS (S ns) = subtermsNS ns\\
subtermsNS (Z np) = subtermsNP np
\vs
subtermsNP :: \fa a xs. NP I xs \ra [a]\\
subtermsNP p (I y :* ys)\\
\s\s | typeEq @a y = witnessEq y : subtermsNP ys\\
\s\s | otherwise\s\s\s = subtermsNP ys\\
subtermsNP \_ Nil = []
\vs
}
The function \texttt{subterms} translates the term to its representation unwrapping the sum of products from \texttt{SOP} and passes that to the auxiliary function \texttt{subtermsNS} that merely traverses the sum until it reaches the product. Once it gets the product, it passes that further to \texttt{subtermsNP}.

The definition of \texttt{subtermsNP} shows the clear idea: it traverses the product adding the element to the result list if its type is the same as a given term's, otherwise skipping that. We use GHC's \textsf{TypeAppications} extension, which allows \emph{visible type applications}, here to fix that type. Note that using this with the type variables appearing in the function signature requires explicit universal quantification.

Now, we need a way to check type equality, and in the case of equal types, to witness that the element is of the appropriate type that admits adding that to the result list of subterms. There is a solution: we can follow \textsf{QuickCheck}'s example and implement this using overlapping instances as it does with \textsf{GHC.Generics}.

The definition of \texttt{subtermsNP} we have shown serves as a clear illustration of the idea and as a template for a more satisfactory solution that we present in Section~\ref{sec:handling-recursion}. But right now, the simplest way to implement this is to rewrite \texttt{subtermsNP} as follows:
\texttt{
\vs
\textbf{class} Subterms a (xs :: [*]) \textbf{where}\\
\s\s subtermsNP :: NP I xs \ra [a]
\vs
\textbf{instance} Subterms a xs \Ra\\
\ind\ind\s Subterms a (x ': xs) \textbf{where}\\
\s\s subtermsNP (\_ :* xs) = subtermsNP xs\\
\textbf{instance} \{-\# OVERLAPS \#-\} Subterms a xs \Ra\\
\ind\ind\s Subterms a (a ': xs) \textbf{where}\\
\s\s subtermsNP (I x :* xs)\\
\s\s\ind = x : subtermsNP xs\\
\textbf{instance} Subterms a '[] \textbf{where}\\
\s\s subtermsNP \_ = []
\vs
}
This uses a type class with the overloaded function. It needs also to declare that all the products in the datatype code are instances of \texttt{Subterms a} by adding a constraint to the \texttt{subterms} and \texttt{subtermsNS} signatures:
\texttt{
\vs
subterms :: (Generic a,\\
\ind\ind\ind\s All (Subterms a) (Code a))\\
\ind\ind\s \Ra a \ra [a]\\
subtermsNS :: All (Subterms a) xss\\
\ind\ind\s\s\s \Ra NS (NP I) xss \ra [a]
\vspace{0.2cm}
}

Though this will work, and there are a number of the Hackage packages that do it in such a manner, we want to write programs free of overlapping because of complexity it introduces into code as we have discussed in Section~\ref{sec:introduction}. Fortunately, we can do without overlapping, and we will demonstrate the solution in the next section.


\section{Handling recursion with closed type families}
\label{sec:handling-recursion}


In Section~\ref{sec:sop-problem}, we have shown a solution to the problem of handling recursion, which makes use of overlapping instances. We are now going to improve the solution and remove overlapping.

Closed type families are the Haskell language extension introduced by~\citet{Eisenberg2014}. Equations for the \emph{closed type family} are disallowed to de defined outside its declaration. Under this extension, we can give the following definition of type-level equality:
\texttt{
\vs
\textbf{type family} Equal a x :: Bool \textbf{where}\\
\s\s Equal a a = 'True\\
\s\s Equal a x = 'False
\vs
}
The equations in a closed type family are matched in a top-to-bottom order. Since the order is always strictly defined, overlapping equations can be used to define sound type-level functions like this type equality.

We now come back to our running example from Section~\ref{sec:sop-problem}. With type equality, we can witness the coersion between the equal types by defining a type class:
\texttt{
\vs
\textbf{class} Proof (eq :: Bool)\\
\ind\ind\ind (a :: *) (b :: *) \textbf{where}\\
\s\s witnessEq :: b -> Maybe a
\vs
\textbf{instance} Proof 'False a b \textbf{where}\\
\s\s witnessEq \_ = Nothing\\
\textbf{instance} Proof 'True a a \textbf{where}\\
\s\s witnessEq\s\s\s = Just
\vs
}
For convenience, we provide a synonym for this. As we need the constraint can be partially applied, we define this as a class with a superclass constraint, rather than as a type synonym:
\texttt{
\vs
\textbf{class} Proof (Equal a b) a b \Ra ProofEq a b\\
\textbf{instance} Proof (Equal a b) a b \Ra ProofEq a b
\vs
}
The following implementation of \texttt{subtermsNP} using this proof resembles our first definition given in Section~\ref{sec:sop-problem}:
\texttt{
\vs
subtermsNP :: \fa a xs. All (ProofEq a) xs\\
\ind\ind\s\s\s \Ra NP I xs \ra [a]\\
subtermsNP (I (y :: x) :* ys)\\
\s\s = case witnessEq @(Equal a x) y of\\
\ind\s\s Just t\s\s \ra t : subtermsNP ys\\
\ind\s\s  Nothing \ra subtermsNP  ys\\
subtermsNP \_ Nil = []
\vs
}
We also make use of \textsf{ScopedTypeVariables} in the definition above, as the type of the element being matched does not appear in the function signature, since it may match an empty list. A proper \texttt{ProofEq} constraint must be added to the \texttt{subterms} and \texttt{subtermsNS} declarations as well.

All generic functions accessing recursive knots in the underlying datatype structure can be defined in this way. We give another detailed example of one of such functions to show how to adapt our idiom to different scenarios.

\subsection{Generic show}

The function \texttt{show} is one of common examples of useful functions that traverse a datatype's recursive structure. It is known that this function can be defined in a generic way for an arbitrary datatype. We follow the implementation of the generic function \texttt{gshow} in \citet{basic-sop} for the most part, but improve it in respect of handling recursion. The original function \texttt{gshow} from \textsf{basic-sop} is not a substitute for the version of \texttt{show} that can be generated for a particular datatype through \texttt{\textbf{deriving} Show}, because it does not consider recursion to place parentheses at points of recursive calls---but we remove this lack of expressiveness.

The following exploits the idea of \emph{pattern matching}. As before, we consider two cases. In the first case when the position we are matching is not recursive, we only require it to be the \texttt{Show} instance, and invoke its \texttt{show}, whereas in the case of the recursion point, we surround it with parentheses and recursively apply our generic function we define next. We again use the defined type equality to model a form of pattern matching on types:
\texttt{
\vs
\textbf{class} CaseShow (eq :: Bool)\\
\ind\ind\ind\s\s\s (a :: *) (b :: *) \textbf{where}\\
\s\s caseShow' :: b \ra String
\vs
\textbf{instance} Show b \Ra CaseShow 'False a b \textbf{where}\\
\s\s caseShow'\s\s\s = show\\
\textbf{instance} GShow a \Ra CaseShow 'True a a \textbf{where}\\
\s\s caseShow' t = "(" ++ gshow t ++ ")"
\vs
\textbf{class} CaseShow (Equal a b) a b \Ra\\
\ind\s\s CaseRecShow a b\\
\textbf{instance} CaseShow (Equal a b) a b \Ra\\
\ind\ind\s CaseRecShow a b
\vs
caseShow :: \fa a b. CaseRecShow a b \Ra b \ra String\\
caseShow t = caseShow' @(Equal a b) @a t
\vs
}
As before, we provide the synonyms in order to reduce the constraints, as well as one for the matching function.

The function \texttt{gshow} involves meta-information to show a datatype constructor's and its record fields' names. It uses the functions that \textsf{generics-sop} provides for handling metadata which it defines separate from the universe, as follows:
\texttt{
\vs
\textbf{type} GShow a = (Generic a, HasDatatypeInfo a,\\
\ind\ind\ind\ind All2 (CaseRecShow a) (Code a))
\vs
gshow :: \fa a. GShow a \Ra a \ra String\\
gshow t = gshow' @a (constructorInfo\\
\ind\ind\ind\ind\ind \$ datatypeInfo\\
\ind\ind\ind\ind\ind \$ Proxy @a) (from t)
\vs
}
The \textsf{generics-sop} library has features for deriving this meta-information automatically. We again define the synonym for the set of the constraints to appear in the function signature. The constraint \texttt{All2} is an analogue of \texttt{All} for a list of lists of types. The functions from \textsf{generics-sop} use a proxy to fix a type value, where we use \textsf{TypeApplications}---a later language extension than those the library relies on.

The auxiliary function \texttt{gshow'} that works on the metadata encoding and generic representation uses \textsf{generics-sop}'s traversal combinators for collapsing and mapping:
\texttt{
\vs
gshow' :: \fa a xss.\\
\ind\ind\s\s (All2 (CaseRecShow a) xss, SListI xss)\\
\ind\s\s\s \Ra NP ConstructorInfo xss\\
\ind\s\s\s \ra SOP I xss \ra String\\
gshow' cs (SOP sop)\\
\ind = hcollapse\\
\ind\s\s \$ hczipWith allp (goConstructor @a) cs sop\\
\s\s \textbf{where}\\
\ind allp = Proxy @(All (CaseRecShow a))
\vs
}
When a sum structure actually is homogeneous (i.~e., has type \texttt{NS~(K~a)~xs}), it can be collapsed to a single component of type \texttt{a}. The respective instantiation of the function \texttt{hcollapse} that generalizes collapsing homogeneous structures is
\texttt{
\vs
hcollapse  :: NS  (K a) xs  \ra  a
\vs
}
The \texttt{hczipWith} function is generalized \texttt{zipWith} that operates with a constrained function on heterogeneous structures, where the proxy fixes the constraint:
\texttt{
\vs
hczipWith :: All c xs\\
\ind\ind\s\s \Ra proxy c\\
\ind\ind\s\s \ra (\fa a. c a \Ra f a \ra g a \ra h a)\\
\ind\ind\s\s \ra NP f xs \ra NS g xs \ra NS h xs
\vs
}
Finally, we show functions, which process constructors and record fields and make use of \texttt{caseShow} (Figure~\ref{fig:cons-fields}). The function \texttt{goConstructor} repeats in general the shape of \texttt{gshow'}, where \texttt{hcmap} generalizes \texttt{map} for \texttt{NP}, \texttt{hczipWith} on two products returns \texttt{NP}, and on two cases, \texttt{hcollapse} collapses the result \texttt{NP} to a list of strings.

The function \texttt{gshow} now can be used to generically show data, for example, a value of type \texttt{Tree~Bool}, where \texttt{Tree~a} (Section~\ref{sec:sop-problem}) is now assumed to be an instance of \texttt{Generic}, and of \texttt{HasDatatypeInfo}:
\texttt{
\vs
**Main> \textbf{let} tree = Node (Leaf True) (Leaf False)\\
*Main> gshow tree
\vs
"Node (Leaf True) (Leaf False)"
\vs
}
And here is a benefit of our implementation: it can be used directly, without any additional instance declarations, whereas \citet{basic-sop} offers the following usage pattern for \texttt{gshow} and some datatype \texttt{T}:
\texttt{
\vs
\textbf{instance} Show T \textbf{where}\\
\s\s show = gshow
\vs
}
This is a consequence of that in \textsf{basic-sop}, the \texttt{gshow} function does not treat recursive positions separately, and therefore requires the \texttt{Show} constraint for all knots in the datatype structure.

\begin{figure}[t]
\begin{tabular}{l}
\tt goConstructor :: \fa a xs. All (CaseRecShow a) xs\\
\tt\ind\ind\ind\s\s \Ra ConstructorInfo xs \ra NP I xs\\
\tt\ind\ind\ind\s\s \ra K String xs\\
\tt goConstructor (Constructor n) args\\
\tt\ind = K \$ unwords (n : args')\\
\tt\s\s \textbf{where}\\
\tt\ind args' :: [String]\\
\tt\ind args' = hcollapse\\
\tt\ind\ind\ind \$ hcmap (p @a)\\
\tt\ind\ind\ind\ind\ind (K . caseShow @a . unI)\\
\tt\ind\ind\ind\ind\ind args\\
\tt goConstructor (Record n ns) args\\
\tt\ind = K \$ n ++ " \{" ++ intercalate ", " args'\\
\tt\ind\ind\ind ++\s\s "\}"\\
\tt\s\s \textbf{where}\\
\tt\ind args' :: [String]\\
\tt\ind args' = hcollapse\\
\tt\ind\ind\ind \$ hczipWith (p @a)\\
\tt\ind\ind\ind\ind\ind\ind (goField @a) ns args\\
\tt goConstructor (Infix n \_ \_)\\
\tt\ind\ind\ind\s\s (I arg1 :* I arg2 :* Nil)\\
\tt\ind = K \$\s\s\s\s caseShow @a arg1\\
\tt\ind\ind\s\s ++ " " ++ n ++ " "\\
\tt\ind\ind\s\s ++ caseShow @a arg2
\vs
\tt p :: Proxy (CaseRecShow a)\\
\tt p = Proxy
\vs
\hline\\
\tt goField :: \fa a x. (CaseRecShow a) x\\
\tt\ind\ind \Ra FieldInfo x \ra I x \ra K String x\\
\tt goField (FieldInfo field) (I y)\\
\tt\ind = K \$ field ++ " = " ++ caseShow @a y
\vs
\hline
\end{tabular}
\caption{Processing constructors and record fields.}
\label{fig:cons-fields}
\end{figure}

\section{The generic Zipper}
\label{sec:generic-zipper}


\section{Related work}
\label{sec:related-work}


\section{Conclusion}
\label{sec:conclusion}

%% Acknowledgments
\begin{acks}                            %% acks environment is optional
                                        %% contents suppressed with 'anonymous'
  %% Commands \grantsponsor{<sponsorID>}{<name>}{<url>} and
  %% \grantnum[<url>]{<sponsorID>}{<number>} should be used to
  %% acknowledge financial support and will be used by metadata
  %% extraction tools.
  This material is based upon work supported by the
  \grantsponsor{GS100000001}{National Science
    Foundation}{http://dx.doi.org/10.13039/100000001} under Grant
  No.~\grantnum{GS100000001}{nnnnnnn} and Grant
  No.~\grantnum{GS100000001}{mmmmmmm}.  Any opinions, findings, and
  conclusions or recommendations expressed in this material are those
  of the author and do not necessarily reflect the views of the
  National Science Foundation.
\end{acks}


%% Bibliography
\bibliography{biblio}


%% Appendix
%\appendix
%\section{Appendix}

%Text of appendix \ldots

\end{document}
